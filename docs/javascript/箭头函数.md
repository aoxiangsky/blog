# [箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## 关于箭头函数的参数

1. 如果箭头函数没有参数，直接写一个空括号即可。
2. 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。
3. 如果箭头函数有多个参数，将参数依次用逗号（，）分隔，包裹在括号中即可。

```js
// 没有参数
let fun1 = () => {
  console.log(111);
};

// 只有一个参数，可以省去参数括号
let fun2 = (name) => {
  console.log(`Hello ${name} !`);
};

// 有多个参数
let fun3 = (val1, val2, val3) => {
  return [val1, val2, val3];
};
```

## 关于箭头函数的函数体

1. 如果箭头函数的函数体只有一句代码，就是简单返回某个变量或者返回一个简单的 JS 表达式，可以省去函数体的大括号`{}`

```js
let f = (val) => val;
// 等同于
let f = function (val) {
  return val;
};

let sum = (num1, num2) => num1 + num2;
// 等同于
let sum = function (num1, num2) {
  return num1 + num2;
};
```

2. 如果箭头函数的函数体只有一句代码，就是返回一个对象，可以像下面这样写：

```js

// 用小括号包裹要返回的对象，不报错
let getTempItem = id => ({ id: id, name: "Temp" });

// 但绝不能这样写，会报错。
// 因为对象的大括号会被解释为函数体的大括号
let getTempItem = id => { id: id, name: "Temp" };

```

3. 如果箭头函数的函数体只有一条语句并且不返回值（最常见的是调用一个函数），可以给这条语句前面加一个`void`关键字

```js
let fn = () => void doesNotReturn();
```

箭头函数最常见的用处就是简化回调函数

```js
// 例子一
// 正常函数写法
[1, 2, 3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1, 2, 3].map((x) => x * x);

// 例子二
// 正常函数写法
var result = [2, 5, 1, 4, 3].sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = [2, 5, 1, 4, 3].sort((a, b) => a - b);
```

## 箭头函数与普通函数的区别

### 语法更加简洁、清晰

从上面的基本语法示例中可以看出，箭头函数的定义要比普通函数定义简洁、清晰得多，很快捷

### 箭头函数不会创建自己的 this

```js

箭头函数不会创建自己的`this`，所以它没有自己的`this`,它只会从自己的作用域链的上一层继承`this`

```

箭头函数没有自己的`this`，它会捕获自己在定义时（注意，是定义时，不是调用时）所处的外层执行环境的`this`，并继承这个`this`值。所以，箭头函数中`this`的指向在它被定义的时候就已经确定了，之后永远不会改变。

```js
var id = "Global";

function fun1() {
  // setTimeout中使用普通函数
  setTimeout(function () {
    console.log(this.id);
  }, 2000);
}

function fun2() {
  // setTimeout中使用箭头函数
  setTimeout(() => {
    console.log(this.id);
  }, 2000);
}

fun1.call({ id: "Obj" }); // 'Global'

fun2.call({ id: "Obj" }); // 'Obj'
```

上面这个例子，函数`fun1`中的`setTimeout`中使用普通函数，2 秒后函数执行时，这时函数其实是在全局作用域执行的，所以`this`指向`Window`对象，`this.id`就指向全局变量`id`，所以输出`Global`。
但是函数`fun2`中的`setTimeout`中使用的是箭头函数，这个箭头函数的`this`在定义时就确定了，它继承了它外层`fun2`的执行环境中的`this`，而`fun2`调用时`this`被`call`方法改变到了对象`{id: 'Obj'}`中，所以输出`Obj`

```js
var id = "GLOBAL";
var obj = {
  id: "OBJ",
  a: function () {
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  },
};

obj.a(); // 'OBJ'
obj.b(); // 'GLOBAL'
```

上面这个例子，对象 obj 的方法 a 使用普通函数定义的，普通函数作为对象的方法调用时，this 指向它所属的对象。所以，this.id 就是 obj.id，所以输出'OBJ'。
但是方法 b 是使用箭头函数定义的，箭头函数中的 this 实际是继承的它定义时所处的全局执行环境中的 this，所以指向 Window 对象，所以输出'GLOBAL'。（这里要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中！！）

### 箭头函数继承而来的 this 指向永远不变（重要!!深入理解！！！）

上面的例子，就完全可以说明箭头函数继承而来的`this`指向永远不变。对象`obj`的方法`b`是使用箭头函数定义的，这个函数中的`this`就永远指向它定义时所处的全局执行环境中的`this`，即便这个函数是作为对象`obj`的方法调用，`this`依旧指向`window`对象。

### call()/apply()/bind()无法改变箭头函数中`this`指向

`call()`/`apply()`/`bind()`方法可以用来动态修改函数执行时`this`的指向，但由于箭头函数的`this`定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数`this`的指向，虽然这么做代码不会报错。

### 箭头函数不能作为构造函数使用

构造函数大概分为以下四步：

1. JS 内部首先会生成一个对象
2. 再把函数中的 this 指向该对象
3. 然后执行构造函数中的语句
4. 最终返回该对象实例

但是，因为箭头函数没有自己的`this`，它的`this`其实是继承了外层执行环境中的`this`，且`this`指向永远不会随意在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用`new`调用会报错！

###  箭头函数没有自己的arguments

箭头函数没有自己的`arguments`对象。在箭头函数中访问`arguments`实际上获得的是外层局部（函数）执行环境中的值

```js
// 例子一
let fun = (val) => {
    console.log(val);   // 111
    // 下面一行会报错
    // Uncaught ReferenceError: arguments is not defined
    // 因为外层全局环境没有arguments对象
    console.log(arguments); 
};
fun(111);

// 例子二
function outer(val1, val2) {
    let argOut = arguments;
    console.log(argOut);    // Arguments(2) [111, 222, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    let fun = () => {
        let argIn = arguments;
        console.log(argIn);     // Arguments(2) [111, 222, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        console.log(argOut === argIn);  // true
    };
    fun();
}
outer(111, 222);
```

可以在箭头函数中使用`rest`参数代替`arguments`对象。来访问箭头函数的参数列表！！

### 箭头函数没有原型`prototype`

```js
let sayHi = () => {
    console.log('Hello World !')
};
console.log(sayHi.prototype); // undefined
```

### 箭头函数不能用作`Generator`函数，不能使用yield关键字

