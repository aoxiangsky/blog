## 什么是闭包

- [MDN定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

> 一个函数对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。也就是说，闭包让你可以在一个内层函数中访问到其外层的作用域。在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

> 简单的来说，闭包就是能够读取其他函数作用域中的变量的函数。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。


## 闭包使用场景：

- 创建私有变量
- 延长变量的生命周期

一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但是创建时所在的词法环境依然存在，以达到延长生命周期的目的。

**柯里化函数**

**模拟私有属性，方法**

在Java这类编程语言中是支持创建私有属性与方法的，所谓私有属性方法其实就是这些属性方法只能被同一个类中的其它方法所调用，但是JavaScript中并未提供专门用于创建私有属性的方法，但我们可以通过闭包模拟它

**其他**

例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期

### 在vue中的使用

```js
function defineRealive(target, key, value){
	return Object.defineProperty(target, key, {
		get(){
			console.log(`通过getter获取数据：${value}`);
			return value;
		},
		set(val){
			console.log(`通过setter设置数据：新值-${val}；旧值-${value}`);
			// 很多人会疑问，value明明是形参，为什么给他赋值就能够达到数值改变的效果呢？形参不是出了这个函数就没用了么？
			// 其实，这就用到了闭包的原理，value是外层函数defineRealive的参数，而我们实际上使用value确是在内层的get或set方法里面
			// 这样就形成了一个闭包的结构了。根据闭包的特性，内层函数可以引用外层函数的变量，并且当内层保持引用关系时外层函数的这个变量
			// 不会被垃圾回收机制回收。那么,我们在设置值的时候，把val保存在value变量当中，然后get的时候再通过value去获取，这样，我们再访问
			// obj.name时，无论是设置值还是获取值，实际上都是对value这个形参进行操作的。
            // 形参也是一个普通的局部变量，只是可能我们平时使用的时候，
           // 一般不会对形参进行赋值操作，因为大部分情况，形参都是外部传入的数据，我们无需修改
			value = val;
		}
	});
}

```

```js
// 根据Vue的$watch原理实现的简易版$watch
Vue.prototype.$watch = function(exp, cb, options = {immediate: true, deep: false}) {
    let watcher = new Watcher(this, exp, cb, options);
    return () => {
        watcher.unWatch();
    };
}
```


## 闭包产生了什么问题：

性能与内存占用，闭包在处理速度和内存消耗方面对脚本性能具有负面影响
