# 执行上下文

简单的来说，执行上下文是一种对`javascript`代码执行环境的抽象概念，也就是说只要`javascript`代码运行，那么它就一定是运行在执行上下文中

## 类型

执行上下文的类型分为三种：

- 全局执行上下文：只有一个，浏览器中的全局对象就是`window`对象，`this`指向这个全局对象
- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
- Eval函数执行上下文：指的是运行在`eval`函数中的代码，很少用而且不建议使用


## 执行栈

执行栈，在其他编程语言中也被称为“调用栈”，这是一种后进先出（LIFO）的数据结构，被用来储存在代码运行阶段创建的所有执行上下文。
当`javaScript`引擎开始执行第一行脚本代码的时候，它会创建一个全局执行上下文然后将它压到执行栈中。每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中。
引擎会执行位于执行栈栈顶的执行上下文（一般是函数执行上下文），当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。

## 生命周期

执行上下文的生命周期包括三个阶段：创建阶段 => 执行阶段 => 回收阶段

### 创建阶段

创建阶段即当函数被调用，但未执行任何其内部代码之前
创建阶段做了三件事：

    - 确定`this`的值，也被称为`This Binding`
    - LexicalEnvironment （词法环境）组件被创建
    - VariableEnvironment（变量环境）组件被创建

伪代码如下：

```js
    ExecutionContext = {  
    ThisBinding = <this value>,     // 确定this 
    LexicalEnvironment = { ... },   // 词法环境
    VariableEnvironment = { ... },  // 变量环境
    }
```

**This Binding**

this的值在执行的时候才能确认，定义的时候不能确认

**词法环境**

词法环境有两个组成部分

- 全局环境：是一个没有外部环境的词法环境，其外部环境引用为`null`，有一个全局对象，`this`的值指向这个全局对象
- 函数环境：用户在函数中定义的变量被存储在环境记录中，包含`arguments`对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境

伪代码如下：

```js

GlobalExectionContext = {  // 全局执行上下文
  LexicalEnvironment: {       // 词法环境
    EnvironmentRecord: {     // 环境记录
      Type: "Object",           // 全局环境
      // 标识符绑定在这里 
      outer: <null>           // 对外部环境的引用
  }  
}

FunctionExectionContext = { // 函数执行上下文
  LexicalEnvironment: {     // 词法环境
    EnvironmentRecord: {    // 环境记录
      Type: "Declarative",      // 函数环境
      // 标识符绑定在这里      // 对外部环境的引用
      outer: <Global or outer function environment reference>  
  }  
}

```

**变量环境**

变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性

在ES6中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（`let`和`const`）绑定，而后者仅用于存储变量（`var`）绑定

变量对象会保存变量声明（Var）、函数参数（arguments）、函数定义（function）

- 变量对象会首先获得函数的参数变量和值
- 获取所有用`function`进行的函数声明，函数名为变量对象的属性名 ，值为函数对象，如果属性已经存在，值会用新值覆盖
- 再依次所有的var关键字进行的变量声明，每找到一个变量声明，就会在变量对象上建一个属性，值为`undefined`，如果变量名已经存在，则会跳过，并不会修改原属性值，`let`,`const`声明的变量并不会在此阶段进行处理
- 函数声明优先级更高，同名的函数会覆盖函数和变量，但同名`var`变量并不会覆盖函数。执行阶段重新赋值可以改变原有的值。

**执行阶段**

- 在函数的调用栈中，如果当前执行上下文处于函数调用栈的顶端，则意味着当前上下文处于激活状态，此时变量对象称为活动对象（AO，Activation Object）VO => AO
- 活动变量包含变量对象所有的属性，并包含`this`指针

在这阶段，执行变量赋值、函数执行，代码执行
如果`javaScript`引擎在源代码声明的实际位置，找不到变量的值，那么将为其分配`undefined`值

**回收阶段**

执行上下文出栈等待虚拟机回收执行上下文

## 全局上下文的变量对象

- 在浏览器里，全局对象为`window`
- 全局上下文里的变量对象为`window`，而且这个变量对象不能激活变成活动对象
- 只要窗口打开，全局上下文会一直存在，所有的上下文都可以直接访问全局上下文变量对象上的属性
- 只有全局上下文的变量对象允许通过VO的属性名称来间接访问，在函数上下文中是不能直接访问VO对象的
- 未进入执行阶段前，变量对象中的属性都不能访问！但是进入到执行阶段后，变量对象转变成了活动对象，里面的属性都能被访问了，对于函数上下文来讲，活动对象与变量对象其实都是同一个对象，只是处于执行上下文的不同生命周期
